#!/bin/sh

### BEGIN INIT INFO
# Provides:          php-{phpVersion}-fpm
# Required-Start:    $remote_fs $network
# Required-Stop:     $remote_fs $network
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: starts php-{phpVersion}-fpm
# Description:       Starts the PHP FastCGI Process Manager daemon
### END INIT INFO

# Author: Aleksey Nemiro <aleksey@nemiro.ru>, 2016-05-15
# Generated by HTAN v{HTAN_Version} at {Now}

TIMEOUT=30
PHP_FPM_CONF="{phpPath}/etc/php-fpm.conf"

NAME="php-{phpVersion}-fpm"
DESC="PHP {phpVersion} FastCGI Process Manager"
PIDFILE="/var/run/$NAME.pid"
DAEMON="{phpPath}/sbin/php-fpm"
DAEMON_ARGS="--daemonize --fpm-config $PHP_FPM_CONF"

# Exit if the package is not executable
[ -x "$DAEMON" ] || exit 0

# Import VERBOSE setting and other rcS variables
. /lib/init/vars.sh

# Import LSB functions
. /lib/lsb/init-functions

if init_is_upstart; then
  exit 1
fi

#======================================================================
# Displays small help.
#======================================================================
usage()
{
  echo "$0 (start|stop|force-quit|restart|reload|status)"
}

#======================================================================
# Performs configuration check.
#======================================================================
do_check()
{
  # set -e
  errors=$($DAEMON --fpm-config $PHP_FPM_CONF -t 2>&1 | grep "\[ERROR\]" || true);

  if [ -n "$errors" ]; then
    echo "Please fix your configuration file..."
    echo $errors
    return 1
  fi

  return 0
}

#======================================================================
# Starts the daemon.
#
# RETURNS:
#   Returns 0 if daemon has been started.
#   Returns 1 if daemon was already running.
#   Returns 2 if daemon could not be started.
#======================================================================
do_start()
{
  start-stop-daemon --start --quiet --pidfile $PIDFILE --name $NAME --exec $DAEMON --test > /dev/null || return 1
  start-stop-daemon --start --quiet --pidfile $PIDFILE --name $NAME --exec $DAEMON -- $DAEMON_ARGS 2>/dev/null || return 2
}

#======================================================================
# Stops the daemon.
#
# RETURNS:
#   Returns 0 if daemon has been stopped.
#   Returns 1 if daemon was already stopped.
#   Returns 2 if daemon could not be stopped.
#   Returns other value for error.
#======================================================================
do_stop()
{
  start-stop-daemon --stop --quiet --retry=QUIT/$TIMEOUT/TERM/5/KILL/5 --pidfile $PIDFILE --name $NAME
  RETVAL="$?"
  [ "$RETVAL" = 2 ] && return 2
  # waiting for children processes to finish
  start-stop-daemon --stop --quiet --oknodo --retry=0/30/TERM/5/KILL/5 --exec $DAEMON
  [ "$?" = 2 ] && return 2
  # remove pid-file
  rm -f $PIDFILE
  return "$RETVAL"
}

#======================================================================
# Sends a SIGHUP to the daemon.
#======================================================================
do_reload() 
{
  start-stop-daemon --stop --signal USR2 --quiet --pidfile $PIDFILE --name $NAME
  return 0
}

case "$1" in
  "start")
    [ "$VERBOSE" != "no" ] && log_daemon_msg "Starting $DESC" "$NAME"
    do_check "$VERBOSE"
    case "$?" in
      0)
        do_start
        case "$?" in
          0|1) [ "$VERBOSE" != "no" ] && log_end_msg 0 ;;
          2) [ "$VERBOSE" != "no" ] && log_end_msg 1 ;;
        esac
      ;;
      1) 
        [ "$VERBOSE" != "no" ] && log_end_msg 1
      ;;
    esac
    ;;
  "stop")
    [ "$VERBOSE" != "no" ] && log_daemon_msg "Stopping $DESC" "$NAME"
    do_stop
    case "$?" in
      0|1) [ "$VERBOSE" != "no" ] && log_end_msg 0 ;;
      2) [ "$VERBOSE" != "no" ] && log_end_msg 1 ;;
    esac
  ;;
  "restart")
    log_daemon_msg "Restarting $DESC" "$NAME"
    do_stop
    case "$?" in
      0|1)
        do_start
        case "$?" in
          0) log_end_msg 0 ;;
          1) log_end_msg 1 ;; # Old process is still running
          *) log_end_msg 1 ;; # Failed to start
        esac
      ;;
      *)
        # Failed to stop
        log_end_msg 1
      ;;
    esac
  ;;
  "reload" | "force-reload")
    log_daemon_msg "Reloading $DESC" "$NAME"
    do_reload
    log_end_msg "$?"
  ;;
  "status")
    status_of_proc "$DAEMON" "$NAME" && exit 0 || exit $?
  ;;
  "check")
    do_check yes
  ;;
  *)
    usage
    exit 1
  ;;
esac

exit 0